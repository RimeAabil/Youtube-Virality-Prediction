# -*- coding: utf-8 -*-
"""Youtube_API_Config.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1tAp5yldnk_6D22iBDOXiyoSQHZ4ytJP1
"""



import os
import logging
import pickle
from typing import Dict, List, Any, Optional, Union
import json

import google.oauth2.credentials
from google_auth_oauthlib.flow import InstalledAppFlow
from google.auth.transport.requests import Request
from googleapiclient.discovery import build
from dotenv import load_dotenv

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

from google.colab import userdata
import os

# Get API key from Colab secrets
YOUTUBE_API_KEY = userdata.get('YOUTUBE_API_KEY')

SCOPES=['https://www.googleapis.com/auth/youtube.readonly']
API_SERVICE_NAME = 'youtube'
API_VERSION = 'v3'
CLIENT_SECRETS_FILE = 'client_secrets.json'
TOKEN_PICKLE_FILE = 'token.pickle'

#creates an object to use when requesting from youtube(the simple one)
def get_authenticated_service_with_api_key():
  if not YOUTUBE_API_KEY:
        raise ValueError(
            "YOUTUBE_API_KEY not found in environment variables. "
            "Please add it to your .env file."
        )
  return build(API_SERVICE_NAME,API_VERSION,developerKey=YOUTUBE_API_KEY)

def get_authenticated_service():
  credentials = None
  #check if we logged in before
  if os.path.exists(TOKEN_PICKLE_FILE):
    with open(TOKEN_PICKLE_FILE,'rb') as token:
      credentials = pickle.load(token)
  #checks if the credentials are expired :
  if credentials and credentials.expired and credentials.refresh_token:
        credentials.refresh(Request())
  if not credentials or not credentials.valid:
        if not os.path.exists(CLIENT_SECRETS_FILE):
            raise FileNotFoundError(
                f'"{CLIENT_SECRETS_FILE}" not found. Please download OAuth 2.0 credentials '
                'from Google Cloud Console and save as client_secrets.json'
            )
        flow = InstalledAppFlow.from_client_secrets_file(CLIENT_SECRETS_FILE, SCOPES)
        credentials = flow.run_local_server(port=8080)
        with open(TOKEN_PICKLE_FILE,'wb') as token:
          pickle.dump(credentials,token)
  return build(API_SERVICE_NAME,API_VERSION, credentials=credentials)

def get_channel_info(youtube, channel_id= None, mine= True):
  if not channel_id and not mine:
     raise ValueError("Either channel_id must be provided or mine must be True")
  part = "snippet,contentDetails,statistics"
  if mine:
    request=youtube.channels().list(part=part,mine=True)
  else :
    request=youtube.channels().list(part=part,id=channel_id)
  response=request.execute()
  logger.info(f"Retrieved channel info: {len(response.get('items', []))} channels")
  return response['items'][0]

def search_videos(youtube, query, maxResults = 50) :
  if maxResults <1 or maxResults > 50 :
    raise ValueError("maxResults must be between 1 and 50")
  request=youtube.search().list(
      part='snippet',
      q=query,
      maxResults=maxResults,
      type='video'
  )
  response = request.execute()
  logger.info(f"Search returned {len(response.get('items', []))} videos")

  return response

def get_video_details(youtube, video_ids) :
  if not video_ids:
    raise ValueError("video_ids cannot be empty")
  if len(video_ids) > 50:
    raise ValueError("video_ids cannot have more than 50 elements")
  part = "snippet,contentDetails,statistics"
  request=youtube.videos().list(
      part=part,
      id=','.join(video_ids)
  )
  response=request.execute()
  logger.info(f"Retrieved details for {len(response.get('items', []))} videos")
  return response['items']

def get_video_comments(youtube, video_id, max_results = 100) :
   request = youtube.commentThreads().list(
        part="snippet",
        videoId=video_id,
        maxResults=min(max_results, 100)
    )
   try:
        response=request.execute()
        logger.info(f"Retrieved {len(response.get('items', []))} comments for video {video_id}")
        return response
   except Exception as e:
        logger.error(f"Error retrieving comments for video {video_id}: {e}")
        return None

def get_subscription_data(youtube, max_results = 50) :
  if max_results <1 or max_results > 50 :
    raise ValueError("max_results must be between 1 and 50")
  request = youtube.subscriptions().list(
        part="snippet,contentDetails",
        mine=True,
        maxResults=min(max_results, 50)
    )
  response=request.execute()
  logger.info(f"Retrieved {len(response.get('items', []))} subscriptions")
  return response

def get_playlist_items(youtube, playlist_id, max_results = 50) :
   request = youtube.playlistItems().list(
        part="snippet,contentDetails",
        playlistId=playlist_id,
        maxResults=min(max_results, 50)
    )
   response = request.execute()
   logger.info(f"Retrieved {len(response.get('items', []))} items from playlist {playlist_id}")

   return response

def save_response_to_json(response, filename) :
  with open(filename, 'w', encoding='utf-8') as f:
          json.dump(response, f, ensure_ascii=False, indent=4)
  logger.info(f"Saved response to {filename}")

import copy
def mask_sensitive_data(data):
    # Create a deep copy to avoid modifying the original data
    masked_data = copy.deepcopy(data)

    # Mask channel owner details if present
    if 'items' in masked_data:
        for item in masked_data['items']:
            # Mask channel owner name in comments
            if 'snippet' in item and 'topLevelComment' in item.get('snippet', {}):
                comment = item['snippet']['topLevelComment']
                if 'authorDisplayName' in comment.get('snippet', {}):
                    comment['snippet']['authorDisplayName'] = f"User_{hash(comment['snippet']['authorDisplayName']) % 10000:04d}"

                # Mask any email-like text in comment content
                if 'textDisplay' in comment.get('snippet', {}):
                    import re
                    email_pattern = r'[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}'
                    comment['snippet']['textDisplay'] = re.sub(
                        email_pattern,
                        '[EMAIL REDACTED]',
                        comment['snippet']['textDisplay']
                    )

            # Mask channel owner details in channel data
            if 'snippet' in item and 'channelTitle' in item['snippet']:
                # Keep first letter and mask the rest
                channel_title = item['snippet']['channelTitle']
                if channel_title:
                    item['snippet']['channelTitle'] = f"{channel_title[0]}{'*' * (len(channel_title) - 1)}"

    return masked_data

print(" RUNNING ALL TESTS...\n")

# Test 1: Authentication
print("1️ API Authentication...")
youtube = get_authenticated_service_with_api_key()
print("    Connected\n")

# Test 2: Search
print("2️Searching videos...")
results = search_videos(youtube, "python", maxResults=3)
print(f"    Found {len(results['items'])} videos\n")

# Test 3: Video Details
print("3️Getting video details...")
video_ids = [item['id']['videoId'] for item in results['items']]
details = get_video_details(youtube, video_ids)
print(f"    Got details for {len(details)} videos\n")

# Test 4: Comments
print("4️ Getting comments...")
comments = get_video_comments(youtube, video_ids[0], max_results=3)
if comments:
    print(f"    Got {len(comments.get('items', []))} comments\n")
else:
    print("    Comments unavailable\n")

# Test 5: Save
print("5️ Saving to JSON...")
save_response_to_json(results, "test_results.json")
print("    Saved\n")

# Test 6: Masking
print("6️ Masking sensitive data...")
if comments:
    masked = mask_sensitive_data(comments)
    print("    Data masked\n")

print(" ALL TESTS COMPLETED!")

